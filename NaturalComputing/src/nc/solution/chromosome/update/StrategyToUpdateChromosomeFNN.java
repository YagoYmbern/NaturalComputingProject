/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package nc.solution.chromosome.update;

import java.util.ArrayList;
import java.util.concurrent.ThreadLocalRandom;
import nc.neurocomputing.activation.Activation_Function;
import nc.solution.ChromosomeFNN;
import nc.solution.Chromosome;
import nc.variable.vneuron.AxonalConnections;
import nc.variable.vneuron.AxonConnection;
import nc.variable.vneuron.CellBodyHidden;
import nc.variable.vneuron.DendriteConnections;
import nc.variable.vneuron.Neuron;
import nc.variable.vneuron.NeuronInput;
import nc.variable.vneuron.NeuronOutput;
import nc.variable.vneuron.Synapsis;
import nc.variable.vneuron.VSynapsis;
import nc.variable.vneuron.VSynapsisUpdater;

/**
 *
 * @author Oscar Lao
 */
public class StrategyToUpdateChromosomeFNN extends StrategyToUpdateChromosome {

    
    @Override
    public void update(Chromosome c) {
            ((ChromosomeFNN) c).update();
    }

//
//    private boolean update_topology = true;
//
//    /**
//     * Do not update anymore the topology
//     */
//    public void do_not_update_topology() {
//        update_topology = false;
//    }
//
//    public void update_topology() {
//        update_topology = true;
//    }
//
//    /**
//     * Update this chromosome. Movements that can be done are, either changing
//     * the values of the connections (weights, slopes) Adding a new connection
//     * between two neurons. Removing a connection between two neurons.
//     *
//     * @param c
//     */
//    @Override
//    public void update(Chromosome c) {
//        if (update_topology) {
//            ((ChromosomeFNN) c).getActivations().updateActivations();
//            double neuron = 0.2;
//            double p = ThreadLocalRandom.current().nextDouble();
//            if (p <= neuron / 2) {
//                add_neuron_between_two_neurons((ChromosomeFNN) c, 1);
//            } else if (p <= neuron) {
//                remove_neuron((ChromosomeFNN) c);
//            } else if (p <= neuron + (1 - neuron) / 2) {
//                add_de_novo_synapses((ChromosomeFNN) c, 1);
//            } else {
//                remove_synapsis((ChromosomeFNN) c);
//            }
//        }
//        mutate_synapsis((ChromosomeFNN) c);
////        mutate_activation_output((ChromosomeFNN) c);
//
//        ((ChromosomeFNN) c).generate_network();
//    }
//
//    /**
//     * Three types of connections are considered: 1) Between two existing
//     * neurons that were already connected: 1.1) Input neuron duplicates and its
//     * descendant connects to the same neuron as the parental neuron. A genetic
//     * dosage compensation is produced, so the two neurons (which would activate
//     * in the same way) share the same weight with alpha and 1-alpha proportion
//     * towards the output neuron. Therefore, the offspring Network will have
//     * EXACTLY the same fitness as the parent network 1.2) Input neuron connects
//     * to a new neuron with weight w1 and the new neuron connects to the output
//     * neuron with weight w2. Genetic compensation is produced so the output of
//     * new neuron is similar to the one produced by the input neuron. Therefore,
//     * the offspring network will tend to have a similar fitness as the parent
//     * 2) Between two existing neurons that were not connected: 2.1) two neurons
//     * that were not connected are linked. Conditions: - k and c are small
//     * enough so the connection initially does not affect the performance of the
//     * network
//     *
//     * @param c
//     */
//    protected void add(ChromosomeFNN c) {
//// a new connection can be generated by three ways: a direct connection between two neurons, a new neuron that appears by copying another neuron
//// by adding a linear neuron between two existing connections.
//        double p = ThreadLocalRandom.current().nextDouble();
//        if (p <= ThreadLocalRandom.current().nextDouble()) {
//            add_neuron_between_two_neurons((ChromosomeFNN) c, 1);
//        } else {
//            add_de_novo_synapses((ChromosomeFNN) c, 1);
//        }
////        } else {
////        }
////        else {
////            duplicate_neuron((ChromosomeFNN) c);
////        }
//        c.generate_network();
//
//    }
//
//    protected void mutate_activation_output(ChromosomeFNN c) {
//        // Pick an output neuron at random
//        int n_out = ThreadLocalRandom.current().nextInt(c.getFr().getOutputs().size());
//        // Update the activation function
//        c.getFr().getOutputs().get(n_out).getAf().updateParameters();
//    }
//
//    protected void mutate_synapsis(ChromosomeFNN c) {
//        int i_synapse = ThreadLocalRandom.current().nextInt(c.size());
//        VSynapsis v = c.get(i_synapse);
//        double p = ThreadLocalRandom.current().nextDouble();
//        if (p < 0.1) {
//            v.getI().setAf(c.getActivations().generate_a_new_activation());
//        } else {
//            v.apply_update();
//        }
//    }
//
//    /**
//     * Add a neuron in an existing synapsis.The new neuron has an activation
//     * function that is generalized Elliot set at parameters k, s and c so it is
//     * a linear activation
//     *
//     * @param c
//     * @param n is the number of neurons to add between synapses
//     */
//    protected void add_neuron_between_two_neurons(ChromosomeFNN c, int n) {
//        // pick a synapse at random. Add a new neuron between the input and output
//        for (int n_s = 0; n_s < n; n_s++) {
//            int i_synapse = ThreadLocalRandom.current().nextInt(c.size());
//            VSynapsis v = c.get(i_synapse);
//            // offspring a. It is a copy of neuron A
//            int id = ThreadLocalRandom.current().nextInt();
//            // Check that the proposed id does not exist already in the list of ids
//            while (c.getFr().getNeuron(new CellBodyHidden(id)) != null) {
//                id = ThreadLocalRandom.current().nextInt();
//            }
//            CellBodyHidden a = new CellBodyHidden(id);
//            VSynapsis A_a = new VSynapsis(new Synapsis(v.getI().getInput_neuron(), a, v.getI().copy_Activation_Function()), new VSynapsisUpdater());
//            // New activation:
//            Activation_Function afr_a_B = c.getActivations().generate_a_new_activation();
////            afr_a_B.getC().getI().setD(old_slope_of_ReLU/v.getI().getAf().getC().getI().getD());
//            VSynapsis a_B = new VSynapsis(new Synapsis(a, v.getI().getOutput_neuron(), afr_a_B), new VSynapsisUpdater());
//            // Remove the old synapsis between A and B in the chromosome
//            c.remove(i_synapse);
//            // Add the new synapses A->a and a->B
//            c.add(A_a);
//            c.add(a_B);
//        }
//    }
//
//    /**
//     * We generate a new synapsis between two neurons that were not connected
//     * before.The slope of the ReLU_Generalized must be something very small in
//     * order to not generate strong deviations from the previous output
//     *
//     * @param c
//     * @param n the number of de novo synapsis that we are going to implement
//     */
//    protected void add_de_novo_synapses(ChromosomeFNN c, int n) {
//        // pick a input neuron. It can be an existing neuron in the network or an input neuron that had no connections
//        ArrayList<Neuron> neurons = c.getFr().getNeurons();
//        for (int syn = 0; syn < n; syn++) {
//            int id_selected_neuron_A = ThreadLocalRandom.current().nextInt(neurons.size());
//            ArrayList<Neuron> possible_partners = new ArrayList<>();
//            // For each of the possible neurons
//            for (Neuron nn : neurons) {
//                // If the neuron is not input, then it can be a partner
//                if (!((nn instanceof NeuronInput))) {
//                    // Get all the axonal connecitons of the neuron A
//                    AxonalConnections axCon = neurons.get(id_selected_neuron_A).getAxons();
//                    // Go through all the connections. Check that the neuron nn is not already in the list of synapses to A
//                    boolean include = true;
//                    for (AxonConnection ax : axCon) {
//                        if (ax.getNeuron().getC().equals(nn.getC())) {
//                            include = false;
//                            break;
//                        }
//                    }
//                    if (include) {
//                        possible_partners.add(nn);
//                    }
//                }
//            }
//
//            if (!possible_partners.isEmpty()) {
//                int id_selected_neuron_B = ThreadLocalRandom.current().nextInt(possible_partners.size());
//                // Adding this synapsis will be likely allowed when re-computing the fitness
//                VSynapsis A_B = new VSynapsis(new Synapsis(neurons.get(id_selected_neuron_A).getC(), (CellBodyHidden) possible_partners.get(id_selected_neuron_B).getC(), c.getActivations().generate_a_new_activation()), new VSynapsisUpdater());
//                // Add the new synapsis between A and B
////            A_B.getI().setTimeWhenSynapsisWasCreated(-10);
//                c.add(A_B);
//            }
//        }
//    }
//
//    /**
//     * Remove a neuron and all its connections. If it is an input Neuron, just
//     * remove all the axon synapses
//     *
//     * @param c
//     */
//    protected void remove_neuron(ChromosomeFNN c) {
//        ArrayList<Neuron> n = c.getFr().getNeurons();
//
//        // Neurons with axons
//        ArrayList<Neuron> n_with_axons = new ArrayList<>();
//
//        for (Neuron nn : n) {
//            // By definition we cannot remove output neurons
//            if (!(nn instanceof NeuronOutput)) {
//                boolean include_in_n_with_axons = true;
//                // Check that the axons are not NeuronOutputs. If they are, check out that they have more dendrites that the neuron here
//                AxonalConnections ax = nn.getAxons();
//                for (AxonConnection aax : ax) {
//                    // If the axon goes to a Neuron output, then check that the Neuron output gets more entrances from other neurons than this
//                    if (aax.getNeuron() instanceof NeuronOutput && aax.getNeuron().getDendrites().size() == 1) {
//                        include_in_n_with_axons = false;
//                        break;
//                    }
//                }
//                if (include_in_n_with_axons) {
//                    n_with_axons.add(nn);
//                }
//            }
//        }
//// Pick one of the eligible neurons at random
//        if (n_with_axons.size() > 0) {
//            int i = ThreadLocalRandom.current().nextInt(n_with_axons.size());
//            // Remove all the axonal connections
//            AxonalConnections axons = n_with_axons.get(i).getAxons();
//
//            axons.forEach((a) -> {
//                c.remove(a.getV());
//            });
//
//            // If it is a hidden neuron, also remove all the dendritic connections
//            DendriteConnections dendrites = n_with_axons.get(i).getDendrites();
//            dendrites.forEach((d) -> {
//                c.remove(d.getV());
//            });
//// Generate the network
//            c.generate_network();
//// Remove the synapses from the chromosome       
//            c.clear();
//// Add the new synapses after removing the ones that are not active anymore        
//            c.addAll(c.getFr().prune());
//        }
//    }
//
//    /**
//     * Remove the connection. An Input cell can have no connection. However,
//     * there must be a path between each output neuron and, at least, one input
//     * neuron. Removing a connection is dangerous because it is likely that it
//     * is going to generate a big jump in the fitness. Intuitively, removing a
//     * connection is going to generate a negative effect in the network. Add
//     * Parental care so the offspring gets help from the fitness of the parents
//     * in case its fitness is worse than the one from the parents.
//     *
//     * @param c
//     */
//    protected void remove_synapsis(ChromosomeFNN c) {
//        ArrayList<VSynapsis> synapsis_to_remove = new ArrayList<>();
//        for (VSynapsis v : c) {
//            if (!(c.getFr().getNeuron(v.getI().getOutput_neuron()) instanceof NeuronOutput && c.getFr().getNeuron(v.getI().getOutput_neuron()).getDendrites().size() == 1)) {
//                synapsis_to_remove.add(v);
//            }
//        }
//        if (!synapsis_to_remove.isEmpty()) {
//// Pick a synapse to erase        
//            int i_synapse = ThreadLocalRandom.current().nextInt(synapsis_to_remove.size());
//            // That would be the chromosome without the synapsis connection
//            c.remove(synapsis_to_remove.get(i_synapse));
//// Generate the network
//            c.generate_network();
//// Remove the synapses        
//            c.clear();
//// Add the new synapses after removing the ones that are not active anymore        
//            c.addAll(c.getFr().prune());
//        }
//    }
}
